## Entropy

熵 $\log_2(\#possibility)$
## Hash

- non-invertible
- collision-resistant
SHA1(bytes)-> 160bits
## Key derivation functions

跟 hash 很像，只不过计算起来比较慢
### Symmetric key cryptography

openssl
### Asymmetric key cryptography

有个问题啊。我感觉 (public key,private key) 是互相绑定的，那这样的话攻击者是不是又可以构造彩虹表一类的东西。
哦，因为 public key,private key 都很长（比如 2048 bits），你很难构建出彩虹表。
### sign and verify

`sign(message,private key) -> signature`
`verify(message,sig,public key) -> OK?`
这样有一个问题，就是比方说两个人在聊天，然后我发了一句 hello 并且 sign 了，如果有人截取到了我对 hello 的 signature，那么以后就能伪造我给别人发 hello。
也就是说，signature 只是相当于我这里官方认证一下，这个文件我之前发过。
所以有一个办法就是加一个时间戳。
所以这个跟物理意义上的 sign 真的很像。

所有的加密算法都有一个问题：在交换公钥阶段，我怎么确定对面就是我要通信的人？换句话说，如果有人从一开始就进行中间人攻击，那么我们的通信就变成透明的了。
事实上，从数学角度，你没有任何手段能确定对面就是你要通信的人。你能给“你要通信的人”下一个定义吗？Ta 具有任何特殊性质吗？
所以，加密算法只能保证，你通信的是拥有这个 public key 对应的 private key 的人。这个人（也可能是一群人）具体是谁，只能线下确定。
嗯，有一个办法。“你要通信的人“应该是由社会关系定义的，所以对面提供社交帐号就行了。当然，这还是相当于假设了没有从一开始就有中间人攻击，不然还是不可行。