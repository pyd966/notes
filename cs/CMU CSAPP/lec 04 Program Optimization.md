## Intro

优化可以在很多不同的层级去做。比如算法、常数、硬件等等。

除了针对一般的机器而言，优化也可以针对某个特定的处理器型号进行。当然，这样做的适用范围会变窄。

在进行优化的过程中，编译器会尽量不改变程序行为。然而，如果你的代码没有遵循规范（UB），仍然可能出现错误。

此外，这还导致，如果编译器不能确定优化是否安全，它就会选择不进行这个优化。

这是由于编译器掌握的信息跟 programmer 是不一样的。programmer 可能知道某个 int 的更精确的实际范围，但是 compiler 不知道。这还有个名字叫 optimization blocker。

## Generally useful optimizations

这些名字完全没用，写下来只是闲的。

### Code Motion

对于重复计算的值，计算一次之后存下来，之后再用。

### Reduction in Strength

把 costly 的操作用更简单的操作代替。比如乘除法。

### Share Common Subexpressions

进行了多次类似的计算，compiler 会提取出相同的部分，然后重复使用。

### Superscalar Processor

CPU 有多个部分，可能负责 Arith,Read,Load 等等，每个部件可能有多个。如果按顺序执行指令，那就很浪费，所以 CPU 一次读取多个指令，拆分成互不影响的若干个部分，分给各个部件去同步执行，尽量让它们别闲着。

此外，对于一些 costly 的指令，我们可以 pipeline 处理。

比方说一次乘法操作需要 3 个 cycle，我们认为每个 cycle 使用的是不同的部分。

那对于很多次不依赖的乘法操作，我不需要等到每个彻底执行完之后再搞下一个，我可以让它们进入流水线。

对于后面那些依赖这些操作的乘法操作，我可以等这些操作进行完之后，清空流水线，然后开始新的流水线。

![[Pasted image 20251015205601.png]]

这就是为什么，循环展开是有用的。不然因为相互依赖，它不敢使用 pipeline。当然还要注意一下运算结合的位置。

你也可以通过使用浮点寄存器的并行计算功能进一步加速。

然而这里有一个下界。读/写是需要时间的，所以得看一下你有几个单元负责这个工作。

### Branch Prediction

如果有条件分支，CPU 会猜一个分支去执行（这样就变成顺序代码了，可以 pipeline 之类的），然后之后真的执行到的时候，再看猜对了没。猜错了就回退。（事实上，每个 reg 有多个副本，回退的时候把值改成确定正确的那个版本）
## Common Optimization Blockers

一旦调用一个 function，compiler 无法对它做出任何假设。所以可以尽量 inline。

在 C 语言中，有可能会有引用别名。这就意味着你写一个循环，然后 `*p += a[i]` 会导致 `*p` 被反复从内存中读取写入，而不是计算完之后再写入。这是因为，编译器无法确定 `p` 是否指向某个 `a[i]`。所以可以使用临时变量 `sum`。