## 浮点表示法

$(-1)^SM2^E$，通常我们规定 $M\in[1,2)$

存是这么存的：

![[Pasted image 20250929101537.png]]

对于 `Single precision`，`S 1bit`，`exp 8bits`，`frac 23bits`。共 `32bits`。

对于 `Double precision`，`S 1bit`，`exp 11bits`，`frac 52bits`。共 `64bits`。

然而，`exp` 并非直接储存 $E$，`frac` 也并非存的是 $M$。

对于 `Normalized Values`，我们要求 $exp$ 不能全 `0` 或全 `1`。

此时，$E=exp-bias$，其中 $exp$ 就是把那部分当成 unsigned 来读，$bias=2^{k-1}-1$，$k$ 是 `exp` 的位数。换句话说，$E\in[-2^{k-1}+2,2^{k-1}-1]$。

$M=1.x\dots$，所以 `frac` 只存小数点后的部分。

对于 `Denormalized Values`，我们要求 `exp` 全 `0`，用来存那些非常接近于 $0$ 的数（包括 $0$，你可以注意到 `Normalized Values` 无法表示 $0$）

此时，$E=1-bias,M=0.x\dots$

比方说 $0$ 就是用 `exp=0,frac=0` 表示的，有正零和负零。

对于 `Special Values`，我们要求 `exp` 全 `1`。

如果 `frac` 全 `0`，那么表示正无穷或者负无穷。溢出的值会变成这个。

比如 `1.0/0.0=-1.0/-0.0=+\infty,1,0/-0.0=-\infty`。

对无穷大任意操作得到的仍然是无穷大。

如果 `frac` 不是全 `0`，那么表示 `NaN`（比如 $\sqrt{-1},\infty-\infty,\infty\times0$）

## 浮点计算

类似地，我们可以先假装我们有无穷位，足以存下两个浮点数运算的结果。接下来，我们考虑如何舍入或者溢出。

有四种舍入方式：向 0，向上，向下，向最近的偶数（default）（其实类似四舍五入，当你恰好在一半的时候，选择向偶数舍入，比方说 1.5 舍入到 2，2.5 也舍入到 2）

默认这么做的目的，是为了让向上舍和向下舍的概率相等，所以统计学意义上误差比较小。

比方说算乘法，符号位做一下，$M$ 直接乘，然后 $E$ 相加，之后把 $M$ 正则化，然后看一下 $E$ 有没有溢出，之后对 $M$ 舍入。

比方说加法，我们的思路是先对齐 $E$ 统一成大的那一个，然后 $M$ 相加，之后正则化，看一下 $E$ 有没有溢出，之后对 $M$ 舍入。

事实上，浮点计算是交换的，但不是结合的。比如 `(3.14+1e10)-1e10=0,3.14+(1e10-1e10)=3.14`

![[Pasted image 20250929113752.png]]

![[Pasted image 20250929113813.png]]

## 类型转换

对于 `float/double->int/long long`，直接丢掉小数部分。

`float->int` 不会出问题，没有舍入。

`double->int` 可能塞不下，

`int->double` 没啥问题

`int->float` 会根据舍入模式进行舍入

## lab

![[Pasted image 20250930205159.png]]