## 题目

以下为回忆版。

### A

> 给两个数 $a,b$，输出 $a+b$ 的十进制下各位数字和。
>
> $a,b\le10^{100}$。

### B

> $n\times m$ 的数表，从左下走到右上，只能向右或向上走，问路径上数之和最大是多少。
>
> $n,m\le 5000$。

### C

> $l\times r$ 的平面直角坐标系，里面已经有 $n$ 个位置打了钉子。你也可以自己打新的钉子，每打一个有代价 $w$。
>
> 打完钉子后，你可以选择一个四个顶点都有钉子、内部没有钉子的矩形（边平行于坐标轴，边上可以有钉子），将其面积作为得分。
>
> 你的目标是使得分减代价最大。
>
> $l,r,w\le 10^9,n\le 5000$。

### D

> 给一个 $n$ 个点 $m$ 条边的有向图，每个点有点权 $w_i$ 和级别 $d_i$。
>
> 我们称一个点集 $S$ 是合法的，当且仅当 $\forall u\in S,v\in V$ 且 $d_u\ge d_v$，都有 $v\in S$。
>
> 点集的权值定义为点集中的点的点权和。
>
> 请输出合法点集的最大权值。
>
> $n\le 5000,m\le 100000,1\le d_i\le 10,|w_i|\le 10^9$。

### E

你是一个云服务供应商，有若干个进程资源、若干内存资源、若干 gpu 资源。

你要写一个调度程序，来处理任务产生的若干种事件：

1. 一个占用一个进程、若干内存、若干 gpu 的任务申请执行，这个任务的优先级是 $w_i$，checkpoint 间隔时长为 $d_i$。
2. 某个任务到达 checkpoint。
3. 某个任务执行完毕。

checkpoint 事件的含义是这样的：任务每执行 $d_i$ 时长，会用此事件通知你的调度程序，你的调度程序可以在此时打断该任务，分配资源给别的任务，这是没有代价的。你的调度程序也可以在非该任务 checkpoint 的时间打断该任务，但是这个任务会丢失自该任务上一个 checkpoint 开始至今的进度。

还有一点特殊之处：任务申请执行时，你的调度程序并不知道它需要多少个 checkpoint。换言之，你不知道任务所需总时长。任务会在结束时通知你的调度程序，并且保证任务只会在自己的某一个 checkpoint 时结束。

记第 $i$ 个任务从申请执行到执行完毕的用时是 $T_i$，你的目标是最小化 $\sum w_iT_i$。

## 解析

### A

模拟高精加法，或者先计算 $a,b$ 的数字和之和，然后在加法过程中，每进位一次就 $-9$ 也可以。

### B

经典 DP 问题。

### C

考场上迷迷糊糊的，想了一个有一点复杂的做法。

首先，因为我们打钉子、选矩形一定是在某个钉子或者边界处进行的，所以先进行离散化，把 $l,r$ 调到跟 $n$ 同阶。

注意到，额外打钉子的操作大概率能通过简单的讨论解决掉，不是难点。先考虑如何解决矩形内部不能有钉子的限制。

先枚举一维 $x$ 坐标作为矩形的左边界，再扫描线开始向右扫，作为矩形的右边界，使用 `set<pair<int,int> >` 维护所有内部没有钉子的 $y$ 区间。因为扫描的过程中只会新增钉子，所以我们只需要支持 split 操作就能在合理时间内维护这个 set。

现在我们已经限制好了左右边界，并且已经知道上下边界满足怎样条件的矩形是合法的了。下面就是简单分讨统计一下。

若最终矩形利用了已有的 0 个钉子。我们找到上述 set 中最长的那个 $y$ 区间就是答案。

若最终矩形利用了已有的 1 个钉子。我们枚举左边界上的一个钉子，将其作为左下角点，找到它所处合法区间的 $y$ 上界即可。对于这个钉子作为左上、右上、右下的情况，如果类似讨论过于复杂，所以我们采用一个小技巧：在最开始，把每个点的 $x$ 坐标变成 $l-x$，这样相当于沿 $y$ 轴翻转，就能解决右下的情况。类似地，只要把整个过程计算 $4$ 次，就能避免讨论。

若最终矩形利用了已有的 2 个钉子。仍然枚举一个左下钉子，通过 `upper_bound` 找到左边界上 $y$ 最大的合法钉子，即可解决这两个钉子在一条边上的情况。如若两个钉子在对角线上，我们在最后单独处理。

若最终矩形利用了已有的 3 个钉子，不妨假设右上钉子是自己打的。枚举左下钉子，使用类似的方法，找到左边界上 $y$ 最大的合法钉子、下边界上 $x$ 最大的合法钉子即可。

若最终矩形利用了已有的 4 个钉子。我们直接独立于上述过程，$O(n^2)$ 枚举对角线的两个钉子，使用二维前缀和判断是否合法。刚刚在 2 个钉子里说的对角线情况在这里一并处理了。

清算复杂度，$O(n^2\log n)$。

说起来有点复杂，实现起来也并不简单。

应该是有更好做法的。

### D

首先，当 $d_i\equiv 1$ 时，这是经典困难问题。所以这个题很难用传统算法解决。

考虑网络流。

因为这是一个 “选了 A 就要选 B” 类型的问题，所以我们采用经典最小割建模。

一个点拆成两个点，左边的跟源点 $s$ 连边，右边的跟汇点 $t$ 连边，左右连一条 `INF` 的边。

我们认为，如果割掉了跟源点连的边，就代表选择这个点；如果割掉跟汇点连的边，就代表不选这个点。

因此根据 $w_i$ 的正负我们可以给边赋权。

下面考虑 “选 A 就要选 B” 的限制。我们不妨记 $A$ 拆成两个点 $A_1,A_2$，$B$ 拆成 $B_1,B_2$。

通过考虑逆否命题的方式，我们发现条件等价于连 $B_1\to A_1$ 边权为 `INF` 的边。

跑网络流即可，跑得飞快。

还有一个小问题：为了知道所有的 “选 A 就要选 B” 的限制，我们需要求转递闭包。

理论上的方法是先缩点，然后每个点开一个 `bool` 数组，对每条边暴力合并，复杂度 $O(nm)$。

实际上我写的是，直接使用 Floyd + bitset，复杂度 $O(\dfrac{n^3}{w})$，评测机神力跑得飞快。

### E

写这个题的时候，前面 C 没调出来，坐得也有点烦躁了。

省流：不会！！！

我实现了一个最简单的，把任务丢到队列里，然后一旦有可以执行的任务，就挑一个占用资源最少的发射过去执行；否则等待。这个是 102 分左右。

不去打断任务的话，这应该是极限了。所以想做这个题的读者可以往这个方向仔细想想，主播要赶 ddl 去了=_=。

## 锐评

题目比去年难一点，但是除了工程题没咋想不做评价外，别的题趣味性不强，而且偏板一点。

不过似乎 cacc 的重点也不在算法方面（？）但是还是期待看到更多有意思的题目的。

不过考场发的麦麦真的还不错。